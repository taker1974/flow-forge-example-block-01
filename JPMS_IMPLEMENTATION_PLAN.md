# План реализации готовности к JPMS (Java Platform Module System)

## Цель

Подготовить модуль `flow-forge-example-block-01` для динамической загрузки через JPMS `ModuleLayer` с возможностью обнаружения классов через рефлексию по аннотации `@BlockPlugin`.

## Шаги реализации

### Шаг 1: Анализ зависимостей и определение их модульности

**Задача:** Определить, какие зависимости являются модульными, а какие автоматическими модулями.

**Действия:**

1. Проверить наличие `module-info.java` в зависимостях:
   - `flow-forge-sdk` (ru.spb.tksoft.flowforge.sdk)
   - `slf4j-api` (org.slf4j) - стандартный модуль
   - `jakarta.validation-api` (jakarta.validation) - стандартный модуль
   - `tk-log-utils` (ru.spb.tksoft.tk.log.utils)
   - `tk-common-exceptions` (ru.spb.tksoft.tk.common.exceptions)

2. Для немодульных зависимостей определить автоматические имена модулей:
   - Имя JAR файла → автоматическое имя модуля
   - Пример: `flow-forge-sdk-2.0.5.jar` → `flow.forge.sdk`
   - Правило: дефисы заменяются на точки, версия удаляется

**Результат:** Список модульных имен для всех зависимостей.

---

### Шаг 2: Создание module-info.java

**Задача:** Создать дескриптор модуля с правильными директивами.

**Структура файла:**

```java
module ru.spb.tksoft.flowforge.example.block.one {
    // 1. Экспорт пакета
    exports ru.spb.tksoft.flowforge.example.block.one;
    
    // 2. Объявление зависимостей (requires)
    requires org.slf4j;                    // Стандартный модуль
    requires jakarta.validation;          // Стандартный модуль
    requires <flow-forge-sdk-module>;     // Модуль или automatic module
    requires <tk-log-utils-module>;       // Модуль или automatic module
    requires <tk-common-exceptions-module>; // Модуль или automatic module
    
    // 3. Опционально: предоставление сервиса (для ServiceLoader)
    // Если используется ServiceLoader, можно добавить:
    // provides ru.spb.tksoft.flowforge.sdk.contract.Block 
    //     with ru.spb.tksoft.flowforge.example.block.one.ExampleBlockOneImpl;
    
    // Примечание: Для динамической загрузки с рефлексией по аннотациям
    // 'provides' не обязателен, так как загрузчик будет сканировать классы напрямую.
}
```

**Действия:**

1. Создать файл `src/main/java/module-info.java`
2. Определить имя модуля: `ru.spb.tksoft.flowforge.example.block.one`
3. Добавить `exports` для пакета с реализацией
4. Добавить `requires` для всех зависимостей
5. Опционально: добавить `provides` для ServiceLoader (если нужен)

**Результат:** Созданный `module-info.java` файл.

---

### Шаг 3: Определение имен модулей для зависимостей

**Задача:** Определить правильные имена модулей для `requires` директив.

**Методы определения:**

1. **Проверка наличия module-info.java в JAR:**

   ```bash
   jar -tf ~/.m2/repository/ru/spb/tksoft/flow-forge-sdk/2.0.5/flow-forge-sdk-2.0.5.jar | grep module-info
   ```

2. **Для автоматических модулей:**
   - Имя формируется из имени JAR файла
   - Удаляется версия и расширение
   - Дефисы заменяются на точки
   - Примеры:
     - `flow-forge-sdk-2.0.5.jar` → `flow.forge.sdk`
     - `tk-log-utils-2.0.2.jar` → `tk.log.utils`
     - `tk-common-exceptions-1.0.0.jar` → `tk.common.exceptions`

3. **Для стандартных модулей:**
   - `org.slf4j` - стандартное имя
   - `jakarta.validation` - стандартное имя

**Действия:**

1. Проверить каждую зависимость на модульность
2. Определить имя модуля (модульное или автоматическое)
3. Задокументировать результаты

**Результат:** Список имен модулей для всех зависимостей.

**Выполнено:** ✅

Определены имена модулей для всех зависимостей:

| Зависимость | Имя модуля | Тип | Статус |
|------------|-----------|-----|--------|
| `flow-forge-sdk-2.0.5.jar` | `ru.spb.tksoft.flowforge.sdk` | Модульный | ✅ |
| `slf4j-api-2.0.17.jar` | `org.slf4j` | Модульный (стандартный) | ✅ |
| `jakarta.validation-api-3.1.1.jar` | `jakarta.validation` | Модульный (стандартный) | ✅ |
| `tk-log-utils-2.0.5.jar` | `ru.spb.tksoft.utils.log` | Модульный | ✅ |
| `tk-common-exceptions-2.0.5.jar` | `ru.spb.tksoft.common.exceptions` | Модульный | ✅ |

**Примечание:** Все зависимости являются модульными (имеют `module-info.class`), автоматические модули не требуются.

---

### Шаг 4: Настройка компиляции с module-info.java

**Задача:** Убедиться, что Maven компилирует модуль правильно.

**Проверки:**

1. Maven compiler plugin поддерживает JPMS (версия 3.8+)
2. Текущая версия: `3.14.1` ✅
3. Java версия: `21` ✅

**Действия:**

1. Проверить, что `maven-compiler-plugin` настроен правильно
2. Выполнить компиляцию: `mvn clean compile`
3. Исправить ошибки компиляции (если есть)

**Результат:** Успешная компиляция модуля.

**Выполнено:** ✅

- Maven compiler plugin версии `3.14.1` поддерживает JPMS ✅
- Java версия `21` настроена правильно ✅
- Компиляция выполнена успешно: `mvn clean compile` ✅
- Ошибок компиляции не обнаружено ✅

---

### Шаг 5: Тестирование компиляции и сборки

**Задача:** Убедиться, что модуль собирается и работает.

**Тесты:**

1. Компиляция: `mvn clean compile`
2. Сборка JAR: `mvn clean package`
3. Проверка содержимого JAR: `jar -tf target/flow-forge-example-block-01-1.0.0.jar | grep module-info`

**Ожидаемые результаты:**

- ✅ Компиляция проходит без ошибок
- ✅ JAR файл содержит `module-info.class`
- ✅ Все зависимости разрешаются корректно

**Результат:** Успешная сборка модульного JAR.

**Выполнено:** ✅

- Компиляция: `mvn clean compile` - успешно ✅
- Сборка JAR: `mvn clean package` - успешно ✅
- Проверка содержимого JAR: `module-info.class` найден в JAR ✅
- Все зависимости разрешаются корректно ✅

---

### Шаг 6: Документирование использования

**Задача:** Создать документацию по использованию модуля в JPMS сценарии.

**Содержание документации:**

1. Имя модуля для загрузки
2. Пример кода загрузчика через `ModuleLayer`
3. Пример обнаружения классов с аннотацией `@BlockPlugin`
4. Пример создания экземпляров

**Результат:** Документация по использованию.

**Выполнено:** ✅

Создан файл `JPMS_USAGE.md` с полной документацией по использованию модуля в JPMS сценарии:

1. ✅ Имя модуля для загрузки: `ru.spb.tksoft.flowforge.example.block.one`
2. ✅ Примеры кода загрузчика через `ModuleLayer`:
   - Базовая загрузка модуля
   - Загрузка модуля с зависимостями
3. ✅ Примеры обнаружения классов с аннотацией `@BlockPlugin`:
   - Базовое сканирование через рефлексию
   - Улучшенное сканирование с использованием ClassLoader
4. ✅ Примеры создания экземпляров:
   - Создание через рефлексию
   - Прямое создание экземпляра
5. ✅ Полный пример использования всех компонентов вместе
6. ✅ Документация зависимостей модуля
7. ✅ Примечания по использованию

---

## Риски и решения

### Риск 1: Зависимости не являются модулями

**Решение:** Использовать автоматические имена модулей на основе имен JAR файлов.

### Риск 2: Конфликты имен автоматических модулей

**Решение:** Проверить фактические имена JAR файлов в локальном репозитории Maven.

### Риск 3: Зависимости требуют дополнительных модулей

**Решение:** Добавить транзитивные зависимости через `requires transitive`.

### Риск 4: Несовместимость версий модулей

**Решение:** Убедиться, что все зависимости совместимы с JPMS.

---

## Критерии готовности

Модуль считается готовым к JPMS, если:

1. ✅ `module-info.java` создан и компилируется
2. ✅ Все зависимости разрешаются корректно
3. ✅ JAR файл содержит `module-info.class`
4. ✅ Модуль может быть загружен через `ModuleLayer`
5. ✅ Классы с аннотацией `@BlockPlugin` могут быть обнаружены через рефлексию
6. ✅ Экземпляры могут быть созданы через публичный конструктор

---

## Следующие шаги после реализации

1. Создать пример загрузчика модуля через `ModuleLayer`
2. Протестировать динамическую загрузку
3. Интегрировать в основное приложение
